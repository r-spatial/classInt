[{"path":"https://r-spatial.github.io/classInt/articles/headtailsR.html","id":"abstract","dir":"Articles","previous_headings":"","what":"Abstract","title":"Head/Tails breaks","text":"vignette discusses implementation “Head/tail breaks” style (Jiang (2013)) classIntervals function. step--step example presented order clarify method. case study using spData::afcon also included, well test suite checking performance validation implementation.","code":""},{"path":"https://r-spatial.github.io/classInt/articles/headtailsR.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Head/Tails breaks","text":"Head/tail breaks, sometimes referred ht-index (Jiang Yin (2013)), classification scheme introduced Jiang (2013) order find groupings hierarchy data heavy-tailed distribution. Heavy-tailed distributions heavily right skewed, minority large values head majority small values tail. imbalance head tail, many small values large values, can expressed “far small things large things”. Heavy tailed distributions commonly characterized power law, lognormal exponential function. Nature, society, finance (Vasicek (2002)) daily lives full rare extreme events, termed “black swan events” (Taleb (2008)). line thinking provides good reason reverse thinking focusing low-frequency events.","code":"library(classInt)  #1. Characterization of heavy-tail distributions---- set.seed(1234) #Pareto distribution a=1 b=1.161 n=1000 sample_par <- 1 / (1 - runif(1000)) ^ (1 / 1.161) opar <- par(no.readonly = TRUE) par(mar = c(2, 4, 3, 1), cex = 0.8) plot(   sort(sample_par, decreasing = TRUE),   type = \"l\",   ylab = \"F(x)\",   xlab = \"\",   main = \"80/20 principle\" ) abline(h = quantile(sample_par, .8) ,        lty = 2,        col = \"red3\") abline(v = 0.2*length(sample_par) ,        lty = 2,        col = \"darkblue\") legend(   \"topleft\",   legend = c(\"F(x): p80\", \"x: Top 20%\"),   col = c(\"red3\", \"darkblue\"),   lty = 2,   cex = 0.8 )  hist(   sample_par,   n = 100,   xlab = \"\",   main = \"Histogram\",   col = \"grey50\",   border = NA,    probability = TRUE ) par(opar)"},{"path":"https://r-spatial.github.io/classInt/articles/headtailsR.html","id":"breaking-method","dir":"Articles","previous_headings":"","what":"Breaking method","title":"Head/Tails breaks","text":"method consists four-step process performed recursively stopping condition satisfied. Given vector values var process can described follows: Compute mu = mean(var). Break var tail (var < mu) head (var > mu). Assess proportion head var lower equal given threshold (.e. length(head)/length(var) <= thr) 3 TRUE, repeat 1 3 condition FALSE partitions possible (.e. head less two elements expressed length(head) < 2). important note , beginning new iteration, var replaced head. underlying hypothesis create partitions head tail balanced terms distribution.stopping criteria satisfied last head last tail evenly balanced. terms threshold, Jiang, Liu, Jia (2013) set 40% good approximation, meaning head contains 40% observations distribution considered heavy-tailed. final breaks vector consecutive mu.","code":""},{"path":"https://r-spatial.github.io/classInt/articles/headtailsR.html","id":"step-by-step-example","dir":"Articles","previous_headings":"","what":"Step by step example","title":"Head/Tails breaks","text":"reproduce pseudo-code1 per Jiang (2019): step--step example R (illustrative purposes) developed:  can seen, iteration resulting head gradually loses high-tail property, stopping condition met. resulting breaks defined breaks = c(min(var), mu(iter=1), ..., mu(iter), max(var)).","code":"Recursive function Head/tail Breaks:  Rank the input data from the largest to the smallest  Break the data into the head and the tail around the mean;  // the head for those above the mean  // the tail for those below the mean  While (head <= 40%):  Head/tail Breaks (head); End Function opar <- par(no.readonly = TRUE) par(mar = c(2, 2, 3, 1), cex = 0.8) var <- sample_par thr <- .4 brks <- c(min(var), max(var))  #Initialise with min and max  sum_table <- data.frame(   iter = 0,   mu = NA,   prop = NA,   n_var = NA,   n_head = NA ) #Pars for chart limchart <- brks #Iteration for (i in 1:10) {   mu <- mean(var)   brks <- sort(c(brks, mu))   head <- var[var > mu]   prop <- length(head) / length(var)   stopit <- prop < thr & length(head) > 1   sum_table = rbind(sum_table,                     c(i, mu, prop, length(var), length(head)))   hist(     var,     main = paste0(\"Iter \", i),     breaks = 50,     col = \"grey50\",     border = NA,     xlab = \"\",     xlim = limchart   )   abline(v = mu, col = \"red3\", lty = 2)   ylabel <- max(hist(var, breaks = 50, plot = FALSE)$counts)   labelplot <- paste0(\"PropHead: \", round(prop * 100, 2), \"%\")   text(     x = mu,     y = ylabel,     labels = labelplot,     cex = 0.8,     pos = 4   )   legend(     \"right\",     legend = paste0(\"mu\", i),     col = c(\"red3\"),     lty = 2,     cex = 0.8   )   if (isFALSE(stopit))     break   var <- head } par(opar)"},{"path":"https://r-spatial.github.io/classInt/articles/headtailsR.html","id":"implementation-in-classint-package","dir":"Articles","previous_headings":"","what":"Implementation in classInt package","title":"Head/Tails breaks","text":"implementation classIntervals function replicate results: stated Jiang (2013), number breaks naturally determined, however thr parameter help adjust final number. lower value thr provide less breaks larger thr increase number, underlying distribution follows “far small things large things” principle.  method always returns least one break, corresponding mean(var).","code":"ht_sample_par <- classIntervals(sample_par, style = \"headtails\") brks == ht_sample_par$brks #> [1] TRUE TRUE TRUE TRUE TRUE TRUE print(ht_sample_par) #> style: headtails #> [1.000295,5.675463) [5.675463,27.23693) [27.23693,85.17664) [85.17664,264.7126)  #>                 855                 114                  25                   3  #> [264.7126,523.6254]  #>                   3 opar <- par(no.readonly = TRUE) par(mar = c(2, 2, 2, 1), cex = 0.8)  pal1 <- c(\"wheat1\", \"wheat2\", \"red3\")  # Minimum: single break print(classIntervals(sample_par, style = \"headtails\", thr = 0)) #> style: headtails #> [1.000295,5.675463) [5.675463,523.6254]  #>                 855                 145 plot(   classIntervals(sample_par, style = \"headtails\", thr = 0),   pal = pal1,   main = \"thr = 0\" )  # Two breaks print(classIntervals(sample_par, style = \"headtails\", thr = 0.2)) #> style: headtails #> [1.000295,5.675463) [5.675463,27.23693) [27.23693,523.6254]  #>                 855                 114                  31 plot(   classIntervals(sample_par, style = \"headtails\", thr = 0.2),   pal = pal1,   main = \"thr = 0.2\" )  # Default breaks: 0.4 print(classIntervals(sample_par, style = \"headtails\")) #> style: headtails #> [1.000295,5.675463) [5.675463,27.23693) [27.23693,85.17664) [85.17664,264.7126)  #>                 855                 114                  25                   3  #> [264.7126,523.6254]  #>                   3 plot(classIntervals(sample_par, style = \"headtails\"),      pal = pal1,      main = \"thr = Default\")  # Maximum breaks print(classIntervals(sample_par, style = \"headtails\", thr = 1)) #> style: headtails #> [1.000295,5.675463) [5.675463,27.23693) [27.23693,85.17664) [85.17664,264.7126)  #>                 855                 114                  25                   3  #>  [264.7126,391.279)  [391.279,523.6254]  #>                   2                   1 plot(   classIntervals(sample_par, style = \"headtails\", thr = 1),   pal = pal1,   main = \"thr = 1\" ) par(opar)"},{"path":"https://r-spatial.github.io/classInt/articles/headtailsR.html","id":"case-study","dir":"Articles","previous_headings":"","what":"Case study","title":"Head/Tails breaks","text":"Jiang (2013) states “new classification scheme natural natural breaks finding groupings hierarchy data heavy-tailed distribution.” (p. 482), referring Jenks’ natural breaks method. case study compare “headtails” vs. “fisher”, alias Fisher-Jenks algorithm always preferred “jenks” style (see ?classIntervals). example use afcon dataset spData package. Let’s look Top 10 values distribution variable totcon (index total conflict 1966-78):  data shows EG SU data present clear hierarchy rest values. per histogram, can confirm heavy-tailed distribution therefore “far small things large things” principle. testing proof, top “headtails” “fisher” use also “quantile” broader view different breaking styles. “quantile” position-based metric, doesn’t account magnitude F(x) (hierarchy), breaks solely defined position x distribution. Applying three aforementioned methods break data:  observed top three classes “headtails” enclose 5 observations, whereas “fisher” includes 13 observations. terms classification, “headtails” breaks focuses extreme values. next plot compares continuous distribution totcon re-escalated range [1,nclass] versus distribution across breaks style. continuous distribution offset -0.5 order align continuous discrete distributions.  can observed distribution “headtails” breaks also heavy-tailed, closer original distribution. extreme, “quantile” provides quasi-uniform distribution, ignoring totcon hierarchy terms data visualization, compare final map using techniques mentioned . plotting exercise: cex points always 1 5. continuous approach, classes provided. plot used reference. rest styles, col cex point defined per class point.  per results, “headtails” seems provide better understanding extreme values result compared continuous plot. “quantile” style, expected, just provides clustering without taking account real hierarchy. “fisher” plot -two interpretations. also important note “headtails” “fisher” reveal different information can useful depending context. “headtails” highlights outliers, fails providing good clustering tail, “fisher” seems reflect better patterns. can observed values Western Africa Niger River Basin, “headtails” doesn’t highlight special cluster conflicts, “fisher” suggests potential cluster. can confirmed histogram generated previously, concentration totcon around 1,000 visible.","code":"library(spData) data(afcon, package = \"spData\") # Top10 knitr::kable(head(afcon[order(afcon$totcon, decreasing = TRUE),c(\"name\",\"totcon\")],10)) opar <- par(no.readonly = TRUE) par(mar = c(4, 4, 3, 1), cex = 0.8) hist(afcon$totcon,      n = 20,      main = \"Histogram\",      xlab = \"totcon\",      col = \"grey50\",      border = NA, ) plot(   density(afcon$totcon),   main = \"Distribution\",   xlab = \"totcon\", ) par(opar) brks_ht <- classIntervals(afcon$totcon, style = \"headtails\") print(brks_ht) #> style: headtails #>   one of 91,390 possible partitions of this variable into 5 classes #>    [147,1350.619) [1350.619,2488.6)   [2488.6,3819.8)   [3819.8,4998.5)  #>                27                10                 3                 1  #>     [4998.5,5246]  #>                 1 #Same number of classes for \"fisher\" nclass <- length(brks_ht$brks) - 1 brks_fisher <-  classIntervals(afcon$totcon, style = \"fisher\",                                n = nclass) print(brks_fisher) #> style: fisher #>   one of 91,390 possible partitions of this variable into 5 classes #>    [147,693.5) [693.5,1474.5)  [1474.5,2618)  [2618,3942.5)  [3942.5,5246]  #>             12             17              8              3              2  brks_quantile <- classIntervals(afcon$totcon, style = \"quantile\",                                 n = nclass) print(brks_quantile) #> style: quantile #>   one of 91,390 possible partitions of this variable into 5 classes #>       [147,604)     [604,833.6)  [833.6,1137.2) [1137.2,1877.4)   [1877.4,5246]  #>               8               9               8               8               9  pal1 <- c(\"wheat1\", \"wheat2\", \"red3\") opar <- par(no.readonly = TRUE) par(mar = c(2, 2, 2, 1), cex = 0.8) plot(brks_ht, pal = pal1, main = \"headtails\") plot(brks_fisher, pal = pal1, main = \"fisher\") plot(brks_quantile, pal = pal1, main = \"quantile\") par(opar) #Helper function to rescale values help_reescale <- function(x, min = 1, max = 10) {   r <- (x - min(x)) / (max(x) - min(x))   r <- r * (max - min) + min   return(r) } afcon$ecdf_class <- help_reescale(afcon$totcon,                                   min = 1 - 0.5,                                   max = nclass - 0.5) afcon$ht_breaks <-  cut(afcon$totcon,                         brks_ht$brks,                         labels = FALSE,                         include.lowest = TRUE)  afcon$fisher_breaks <-  cut(afcon$totcon,                             brks_fisher$brks,                             labels = FALSE,                             include.lowest = TRUE)  afcon$quantile_break <-  cut(afcon$totcon,                              brks_quantile$brks,                              labels = FALSE,                              include.lowest = TRUE)  opar <- par(no.readonly = TRUE) par(mar = c(4, 4, 1, 1), cex = 0.8) plot(   density(afcon$ecdf_class),   ylim = c(0, 0.8),   lwd = 2,   main = \"\",   xlab = \"class\" ) lines(density(afcon$ht_breaks), col = \"darkblue\", lty = 2) lines(density(afcon$fisher_breaks), col = \"limegreen\", lty = 2) lines(density(afcon$quantile_break),       col = \"red3\",       lty = 2) legend(\"topright\",        legend = c(\"Continuous\", \"headtails\",                   \"fisher\", \"quantile\"),   col = c(\"black\", \"darkblue\", \"limegreen\", \"red3\"),   lwd = c(2, 1, 1, 1),   lty = c(1, 2, 2, 2),   cex = 0.8 ) par(opar) custompal <- c(\"#FE9F6D99\",                \"#DE496899\",                \"#8C298199\",                \"#3B0F7099\",                \"#00000499\")  afcon$cex_points <- help_reescale(afcon$totcon,                                   min = 1,                                   max = 5) opar <- par(no.readonly = TRUE) par(mar = c(1.5, 1.5, 2, 1.5), cex = 0.8) # Plot continuous plot(   x = afcon$x,   y = afcon$y,   axes = FALSE,   cex = afcon$cex_points,   pch = 20,   col = \"grey50\",   main = \"Continuous\", )  mcont <- (max(afcon$totcon) - min(afcon$totcon)) / 4 legcont <- 1:5 * mcont - (mcont - min(afcon$totcon))  legend(\"bottomleft\",        xjust = 1,        bty = \"n\",        legend = paste0(\"   \",                   round(legcont, 0)                   ),        col = \"grey50\",   pt.cex = seq(1, 5),   pch = 20,   title = \"totcon\" ) box()  plot(   x = afcon$x,   y = afcon$y,   axes = FALSE,   cex = afcon$ht_breaks,   pch = 20,   col = custompal[afcon$ht_breaks],   main = \"headtails\" ) legend(   \"bottomleft\",   xjust = 1,   bty = \"n\",   legend = paste0(\"   \",                   round(brks_ht$brks[2:6],0)                   ),   col = custompal,   pt.cex = seq(1, 5),   pch = 20,   title = \"totcon\" ) box()  plot(   x = afcon$x,   y = afcon$y,   axes = FALSE,   cex = afcon$fisher_breaks,   pch = 20,   col = custompal[afcon$fisher_breaks],   main = \"fisher\" ) legend(   \"bottomleft\",   xjust = 1,   bty = \"n\",   legend = paste0(\"   \",                   round(brks_fisher$brks[2:6],0)                   ),   col = custompal,   pt.cex = seq(1, 5),   pch = 20,   title = \"totcon\" ) box()  plot(   x = afcon$x,   y = afcon$y,   axes = FALSE,   cex = afcon$quantile_break,   pch = 20,   col = custompal[afcon$quantile_break],   main = \"quantile\" ) legend(   \"bottomleft\",   xjust = 1,   bty = \"n\",   legend = paste0(\"   \",                   round(brks_quantile$brks[2:6],0)                   ),   col = custompal,   pt.cex = seq(1, 5),   pch = 20,   title = \"totcon\" ) box()  par(opar)"},{"path":"https://r-spatial.github.io/classInt/articles/headtailsR.html","id":"testing-and-benchmark","dir":"Articles","previous_headings":"","what":"Testing and benchmark","title":"Head/Tails breaks","text":"section performance “headtails” implementation tested, terms speed handling corner cases. small benchmark another styles also presented. Testing performed following distributions: Heavy-tailed distributions Pareto Exponential Log-normal Weibull Log-Cauchy, also known super-heavy tail distribution (Falk, Huesler, Reiss (2011), p. 80, Fraga Alves, Haan, Neves (2009)) Non heavy-tailed distributions Normal (non heavy-tailed) Truncated Normal (left-tailed) Uniform distribution Let’s define helper function proceed run whole test suite:  implementation works expected, good performance given size sample, also compares well another current implementations classIntervals.","code":"#Init samples set.seed(2389)  #Pareto distributions a=7 b=14 paretodist <- 7 / (1 - runif(5000000)) ^ (1 / 14) #Exponential dist expdist <- rexp(5000000) #Lognorm lognormdist <- rlnorm(5000000) #Weibull weibulldist <- rweibull(5000000, 1, scale = 5) #LogCauchy \"super-heavy tail\" logcauchdist <- exp(rcauchy(5000000, 2, 4)) #Remove Inf  logcauchdist <- logcauchdist[logcauchdist < Inf]  #Normal dist normdist <- rnorm(5000000) #Left-tailed distr leftnorm <-   sample(rep(normdist[normdist < mean(normdist)], 3), size = 5000000)  #Uniform distribution unifdist <- runif(5000000) testresults <- data.frame(   Title = NA,   style = NA,   nsample  = NA,   thresold = NA,   nbreaks = NA,   time_secs = NA )  benchmarkdist <-   function(dist,            style = \"headtails\",            thr = 0.4,            title = \"\",            plot = FALSE) {     init <- Sys.time()     br <- classIntervals(dist, style = style, thr = thr)     a <- Sys.time() - init     test <- data.frame(       Title = title,       style  = style,       nsample  = format(length(br$var),                          scientific = FALSE, big.mark = \",\"),       thresold = thr,       nbreaks = length(br$brks) - 1,       time_secs = as.character(round(a,4))     )     testresults <- unique(rbind(testresults, test))          if (plot) {       plot(         density(br$var,                 from = quantile(dist,.0005),                 to = quantile(dist,.9995)                 ),         col = \"black\",         cex.main = .9,         main = paste0(           title,           \" \",           style,           \", thr =\",           thr,           \", nbreaks = \",           length(br$brks) - 1         ),         ylab = \"\",         xlab = \"\"       )       abline(v = br$brks,              col = \"red3\",              lty = 2)     }     return(testresults)   } opar <- par(no.readonly = TRUE) par(mar = c(2, 2, 2, 2), cex = 0.8)  # Pareto---- testresults <- benchmarkdist(paretodist, title = \"Pareto\", plot = TRUE) testresults <- benchmarkdist(paretodist, title = \"Pareto\", thr = 0) testresults <- benchmarkdist(paretodist, title = \"Pareto\", thr = .75, plot = TRUE)  #Sample 2,000 obs set.seed(1234) Paretosamp <- sample(paretodist, 2000) testresults <- benchmarkdist(Paretosamp,                              title = \"Pareto sample\",                              style = \"fisher\",                              plot = TRUE) testresults <- benchmarkdist(Paretosamp,                              title = \"Pareto sample\",                              style = \"headtails\",                              plot = TRUE)   #Exponential---- testresults <- benchmarkdist(expdist, title = \"Exponential\", plot = TRUE) testresults <- benchmarkdist(expdist, title = \"Exponential\", thr = 0) testresults <- benchmarkdist(expdist, title = \"Exponential\", thr = 1) testresults <- benchmarkdist(expdist, title = \"Exponential\",                              style = \"quantile\", plot = TRUE)  #Weibull----- testresults <- benchmarkdist(weibulldist, title = \"Weibull\", plot = TRUE) testresults <- benchmarkdist(weibulldist, title = \"Weibull\", thr = 0) testresults <- benchmarkdist(weibulldist, title = \"Weibull\", thr = 1)  #Logcauchy testresults <- benchmarkdist(logcauchdist, title = \"LogCauchy\", plot = TRUE) testresults <- benchmarkdist(logcauchdist, title = \"LogCauchy\", thr = 0) testresults <- benchmarkdist(logcauchdist, title = \"LogCauchy\", thr = 1)  #Normal---- testresults <- benchmarkdist(normdist, title = \"Normal\", plot = TRUE) testresults <- benchmarkdist(normdist, title = \"Normal\", thr = 0) testresults <- benchmarkdist(normdist, title = \"Normal\", thr = 1, plot = TRUE)  #Truncated Left-tail Normal---- testresults <- benchmarkdist(leftnorm, title = \"Left Normal\", plot = TRUE) testresults <- benchmarkdist(leftnorm, title = \"Left Normal\", thr = -100) testresults <- benchmarkdist(leftnorm, title = \"Left Normal\", plot = TRUE, thr = 500)  #Uniform---- testresults <- benchmarkdist(unifdist, title = \"Uniform\", plot = TRUE, thr = 0.7) testresults <- benchmarkdist(unifdist, title = \"Uniform\", thr = 0) testresults <- benchmarkdist(unifdist, title = \"Uniform\", plot = TRUE, thr = 1) par(opar)  # Results knitr::kable(testresults[-1, ], row.names = FALSE)"},{"path":[]},{"path":"https://r-spatial.github.io/classInt/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Roger Bivand. Author, maintainer. Bill Denney. Contributor. Richard Dunlap. Contributor. Diego Hernangómez. Contributor. Hisaji Ono. Contributor. Josiah Parry. Contributor. Matthieu Stigler. Contributor.","code":""},{"path":"https://r-spatial.github.io/classInt/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Bivand R (2024). classInt: Choose Univariate Class Intervals. R package version 0.4-11, https://github.com/r-spatial/classInt/, https://r-spatial.github.io/classInt/.","code":"@Manual{,   title = {classInt: Choose Univariate Class Intervals},   author = {Roger Bivand},   year = {2024},   note = {R package version 0.4-11, https://github.com/r-spatial/classInt/},   url = {https://r-spatial.github.io/classInt/}, }"},{"path":"https://r-spatial.github.io/classInt/index.html","id":"classint","dir":"","previous_headings":"","what":"Choose Univariate Class Intervals","title":"Choose Univariate Class Intervals","text":"Choose Univariate Class Intervals Selected commonly used methods choosing univariate class intervals mapping graphics purposes. 0.4-3, implementation “headtails” style contributed Diego Hernangómez - Jiang, B. 2013 “Head/tail breaks: new classification scheme data heavy-tailed distribution”, Professional Geographer, 65 (3), 482 – 494. https://arxiv.org/abs/1209.2801v1. 0.4-7, implementation “maximum” style contributed Josiah Parry. 0.4-8, implementation “box” style contributed Angela Li Diego Hernangómez.","code":""},{"path":"https://r-spatial.github.io/classInt/index.html","id":"compiling-from-source","dir":"","previous_headings":"","what":"Compiling from source","title":"Choose Univariate Class Intervals","text":"want compile package source, make sure latest version GNU Fortran installed, can find R Development Tools web page use OSX; Windows make sure Rtools includes Fortran. Fortran needed compile Fisher’s original code written Fortran. Migrated R-Forge","code":""},{"path":"https://r-spatial.github.io/classInt/reference/classIntervals.html","id":null,"dir":"Reference","previous_headings":"","what":"Choose univariate class intervals — classIntervals","title":"Choose univariate class intervals — classIntervals","text":"function provides uniform interface finding class intervals continuous numerical variables, example choosing colours symbols plotting. Class intervals non-overlapping, classes left-closed — see findInterval. Argument values style chosen passed dot arguments. classIntervals2shingle converts classIntervals object shingle. Labels generated methods like found cut unless cutlabels=FALSE.","code":""},{"path":"https://r-spatial.github.io/classInt/reference/classIntervals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Choose univariate class intervals — classIntervals","text":"","code":"classIntervals(var, n, style = \"quantile\", rtimes = 3, ...,  intervalClosure = c(\"left\", \"right\"), dataPrecision = NULL,  warnSmallN = TRUE, warnLargeN = TRUE, largeN = 3000L, samp_prop = 0.1,  gr = c(\"[\", \"]\")) # S3 method for class 'classIntervals' plot(x, pal, ...) # S3 method for class 'classIntervals' print(x, digits = getOption(\"digits\"), ...,  under=\"under\", over=\"over\", between=\"-\", cutlabels=TRUE, unique=FALSE,big.mark=NULL) nPartitions(x) classIntervals2shingle(x)"},{"path":"https://r-spatial.github.io/classInt/reference/classIntervals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Choose univariate class intervals — classIntervals","text":"var continuous numerical variable n number classes required, missing, nclass.Sturges used; see also \"dpih\" \"headtails\" styles automatic choice number classes style chosen style: one \"fixed\", \"sd\", \"equal\", \"pretty\", \"quantile\", \"kmeans\", \"hclust\", \"bclust\", \"fisher\", \"jenks\", \"dpih\", \"headtails\", \"maximum\", \"box\" rtimes number replications var catenate jitter; may used styles \"kmeans\" \"bclust\" case difficulties reaching classification intervalClosure default “left”,  allows specification whether partition intervals closed left right (added Richard Dunlap). Note sense interval closure hard-coded “right”-closed whenstyle=\"jenks\" (see Details ). dataPrecision default NULL, permits rounding interval endpoints (added Richard Dunlap). data precision used printing interval values legend returned findColours, print method classIntervals objects. intervalClosure “left”, value returned ceiling data value multiplied 10 dataPrecision power, divided 10 dataPrecision power. argument round var, input variable. warnSmallN default TRUE, FALSE, quietens warning n >= nobs warnLargeN default TRUE, FALSE large data handling used largeN default 3000L, QGIS sampling threshold; warnLargeNis TRUE number observations greater largeN, observations presented \"fisher\" \"jenks\" either samp_prop= sample observations, sample largeN, whichever smaller samp_prop default 0.1, QGIS 10% sampling proportion gr default c(\"[\", \"]\"), units package available, units::units_options(\"group\") may used directly give enclosing bracket style ... arguments passed functions called style x \"classIntervals\" object printing, conversion shingle, plotting character string value \"\" printed table labels cutlabels=FALSE character string value \"\" printed table labels cutlabels=FALSE character string value \"\" printed table labels cutlabels=FALSE digits minimal number significant digits printed table labels cutlabels default TRUE, use cut-style labels printed table labels unique default FALSE; TRUE, collapse labels single-value classes big.mark default NULL; object class character specify 'thousands' separator pal character vector least two colour names colour coding class intervals ECDF plot; colorRampPalette used internally create correct number colours","code":""},{"path":"https://r-spatial.github.io/classInt/reference/classIntervals.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Choose univariate class intervals — classIntervals","text":"\"fixed\" style permits \"classIntervals\" object specified given breaks, set fixedBreaks argument; length fixedBreaks n+1; style can used insert rounded break values. \"sd\" style chooses breaks based pretty centred scaled variables, may number classes different n; returned par= includes centre scale values. argument sd_m given numeric vector multiples apply standard deviation c(-Inf, -2, -1, 0, 1, 2, +Inf) \"equal\" style divides range variable n parts. \"pretty\" style chooses number breaks necessarily equal n using pretty, likely legible; arguments pretty may passed .... \"quantile\" style provides quantile breaks; arguments quantile may passed .... Rather giving probs, use n argument default probs = seq(0, 1, 1/n). probs given, span unit interval [0, 1]. given probs values equal steps, consider using style = \"fixed\" giving \"fixedBreaks\" directly. \"kmeans\" style uses kmeans generate breaks; may anchored using set.seed; pars attribute returns kmeans object generated; kmeans fails, jittered input vector containing rtimes replications var tried — unique values var, can prove necessary; arguments kmeans may passed .... \"hclust\" style uses hclust generate breaks using hierarchical clustering; pars attribute returns hclust object generated, can used find breaks using getHclustClassIntervals; arguments hclust may passed .... \"bclust\" style uses bclust generate breaks using bagged clustering; may anchored using set.seed; pars attribute returns bclust object generated, can used find breaks using getBclustClassIntervals; bclust fails, jittered input vector containing rtimes replications var tried — unique values var, can prove necessary; arguments bclust may passed .... \"fisher\" style uses algorithm proposed W. D. Fisher (1958) discussed Slocum et al. (2005) Fisher-Jenks algorithm; added thanks Hisaji Ono. style subsample default 3000 observations. style always preferred \"jenks\" uses original Fortran code runs nested -loops much faster. \"jenks\" style ported Jenks' code, checked consistency ArcView, ArcGIS, MapInfo (remaining differences); added thanks Hisaji Ono (originally reported Basic, now seen Fortran (described talk last seen http://www.irlogi.ie/wp-content/uploads/2016/11/NUIM_ChoroHarmful.pdf, slides 26-27)). Note sense interval closure reversed styles, implementation right-closed - use cutlabels=TRUE findColours object returned show closure clearly, use findCols extract classes value. style subsample default 3000 observations. \"dpih\" style uses dpih() function KernSmooth (Wand, 1995) implementing direct plug-methodology select bin width histogram. \"headtails\" style uses algorithm proposed Bin Jiang (2013), order find groupings hierarchy data heavy-tailed distribution. classification scheme partitions data values around mean two parts continues process iteratively values (mean) head head part values longer heavy-tailed distributed. Thus, number classes class intervals naturally determined. default algorithm uses thr = 0.4, meaning head represents 40% observations distribution considered heavy-tailed. threshold argument thr may modified ... (see Examples). \"maximum\" style uses Maximum Breaks method classification finding k - 1 largest differences var. mean values generated largest splits used interval boundary. \"box\" style generates 7 breaks (therefore 6 categories) based box--whisker plot. First last categories include data values considered outliers, four remaining categories defined percentiles 25, 50 75 data distribution. default, identification outliers based interquantile range (IQR), values lower percentile 25 - 1.5 * IQR higher percentile 75 + 1.5 * IQR considered outliers. multiplier applied IQR iqr_mult = 1.5 may modified ...; value must negative. \"quantile\" style, type= argument may used choose quantile algoritm (default 7, standard boxplots use 5 2). 0.4-9 #41, maximum minimum set +Inf -Inf avoid errors induced earlier version breaks cease strictly ascending. legacy= argument value TRUE may used revert previous behaviour.","code":""},{"path":"https://r-spatial.github.io/classInt/reference/classIntervals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Choose univariate class intervals — classIntervals","text":"object class \"classIntervals\": var input variable brks vector breaks attributes: style style used parameters parameter values used finding breaks nobs number different finite values input variable call function's call intervalClosure string, whether closure “left” “right” dataPrecision data precision used printing interval values legend returned findColours, print method classIntervals objects. intervalClosure “left”, value returned ceiling data value multiplied 10 dataPrecision power, divided 10 dataPrecision power.","code":""},{"path":"https://r-spatial.github.io/classInt/reference/classIntervals.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Choose univariate class intervals — classIntervals","text":"Armstrong, M. P., Xiao, N., Bennett, D. ., 2003. \"Using genetic algorithms create multicriteria class intervals choropleth maps\". Annals, Association American Geographers, 93 (3), 595–623; Jenks, G. F., Caspall, F. C., 1971. \"Error choroplethic maps: definition, measurement, reduction\". Annals, Association American Geographers, 61 (2), 217–244; Dent, B. D., 1999, Cartography: thematic map design. McGraw-Hill, Boston, 417 pp.; Slocum TA, McMaster RB, Kessler FC, Howard HH 2005 Thematic Cartography Geographic Visualization, Prentice Hall, Upper Saddle River NJ.; Fisher, W. D. 1958 \"grouping maximum homogeneity\", Journal American Statistical Association, 53, pp. 789–798 (https://lib.stat.cmu.edu/cmlib/src/cluster/fish.f) Wand, M. P. 1995. Data-based choice histogram binwidth. American Statistician, 51, 59-64. Jiang, B. 2013 \"Head/tail breaks: new classification scheme data heavy-tailed distribution\", Professional Geographer, 65 (3), 482 – 494. (https://arxiv.org/abs/1209.2801v1)","code":""},{"path":"https://r-spatial.github.io/classInt/reference/classIntervals.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Choose univariate class intervals — classIntervals","text":"Roger Bivand <Roger.Bivand@nhh.>","code":""},{"path":"https://r-spatial.github.io/classInt/reference/classIntervals.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Choose univariate class intervals — classIntervals","text":"version 0.1-11, default representation changed use cutlabels=TRUE, representation within intervals corrected, thanks Richard Dunlap. version 0.1-15, print method drops calculation possible number combinations observations classes, generated warnings n > 170.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/classInt/reference/classIntervals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Choose univariate class intervals — classIntervals","text":"","code":"if (!require(\"spData\", quietly=TRUE)) {   message(\"spData package needed for examples\")   run <- FALSE } else {   run <- TRUE } if (run) { data(jenks71, package=\"spData\") pal1 <- c(\"wheat1\", \"red3\") opar <- par(mfrow=c(2,3)) plot(classIntervals(jenks71$jenks71, n=5, style=\"fixed\",  fixedBreaks=c(15.57, 25, 50, 75, 100, 155.30)), pal=pal1, main=\"Fixed\") plot(classIntervals(jenks71$jenks71, n=5, style=\"sd\"), pal=pal1, main=\"Pretty standard deviations\") plot(classIntervals(jenks71$jenks71, n=5, style=\"equal\"), pal=pal1, main=\"Equal intervals\") plot(classIntervals(jenks71$jenks71, n=5, style=\"quantile\"), pal=pal1, main=\"Quantile\") set.seed(1) plot(classIntervals(jenks71$jenks71, n=5, style=\"kmeans\"), pal=pal1, main=\"K-means\") plot(classIntervals(jenks71$jenks71, n=5, style=\"hclust\", method=\"complete\"),  pal=pal1, main=\"Complete cluster\") }  if (run) { plot(classIntervals(jenks71$jenks71, n=5, style=\"hclust\", method=\"single\"),  pal=pal1, main=\"Single cluster\") set.seed(1) plot(classIntervals(jenks71$jenks71, n=5, style=\"bclust\", verbose=FALSE),  pal=pal1, main=\"Bagged cluster\") plot(classIntervals(jenks71$jenks71, n=5, style=\"fisher\"), pal=pal1,  main=\"Fisher's method\") plot(classIntervals(jenks71$jenks71, n=5, style=\"jenks\"), pal=pal1,  main=\"Jenks' method\")  plot(classIntervals(jenks71$jenks71, style=\"dpih\"), pal=pal1,  main=\"dpih method\")  plot(classIntervals(jenks71$jenks71, style=\"headtails\", thr = 1), pal=pal1,  main=\"Head Tails method\")  }  if (run) {  plot(classIntervals(jenks71$jenks71, style=\"maximum\"), pal=pal1,  main=\"Maximum method\")  plot(classIntervals(jenks71$jenks71, style=\"box\"), pal=pal1,  main=\"Box method\")  par(opar) }  if (run) { print(classIntervals(jenks71$jenks71, n=5, style=\"fixed\",  fixedBreaks=c(15.57, 25, 50, 75, 100, 155.30))) } #> style: fixed #>   one of 3,921,225 possible partitions of this variable into 5 classes #>  [15.57,25)     [25,50)     [50,75)    [75,100) [100,155.3]  #>           6          34          42          14           6  if (run) { print(classIntervals(jenks71$jenks71, n=5, style=\"sd\")) } #> style: sd #>   one of 75,287,520 possible partitions of this variable into 6 classes #> [5.514407,30.89691) [30.89691,56.27941) [56.27941,81.66191) [81.66191,107.0444)  #>                  10                  47                  31                   9  #> [107.0444,132.4269) [132.4269,157.8094]  #>                   4                   1  if (run) { print(classIntervals(jenks71$jenks71, n=5, style=\"equal\")) } #> style: equal #>   one of 3,921,225 possible partitions of this variable into 5 classes #>   [15.57,43.516)  [43.516,71.462)  [71.462,99.408) [99.408,127.354)  #>               35               44               17                4  #>  [127.354,155.3]  #>                2  if (run) { print(classIntervals(jenks71$jenks71, n=5, style=\"quantile\")) } #> style: quantile #>   one of 3,921,225 possible partitions of this variable into 5 classes #>  [15.57,33.822) [33.822,50.114) [50.114,57.454) [57.454,73.368)  [73.368,155.3]  #>              21              20              20              20              21  if (run) { set.seed(1) print(classIntervals(jenks71$jenks71, n=5, style=\"kmeans\")) } #> style: kmeans #>   one of 3,921,225 possible partitions of this variable into 5 classes #>  [15.57,36.905)  [36.905,53.33)  [53.33,72.185) [72.185,105.95)  [105.95,155.3]  #>              25              26              29              17               5  if (run) { set.seed(1) print(classIntervals(jenks71$jenks71, n=5, style=\"kmeans\", intervalClosure=\"right\")) } #> style: kmeans #>   one of 3,921,225 possible partitions of this variable into 5 classes #>  [15.57,36.905]  (36.905,53.33]  (53.33,72.185] (72.185,105.95]  (105.95,155.3]  #>              25              26              29              17               5  if (run) { set.seed(1) print(classIntervals(jenks71$jenks71, n=5, style=\"kmeans\", dataPrecision=0)) } #> style: kmeans #>   one of 3,921,225 possible partitions of this variable into 5 classes #>   [16,37)   [37,54)   [54,73)  [73,106) [106,156]  #>        25        26        29        17         5  if (run) { set.seed(1) print(classIntervals(jenks71$jenks71, n=5, style=\"kmeans\"), cutlabels=FALSE) } #> style: kmeans #>   one of 3,921,225 possible partitions of this variable into 5 classes #>    under 36.905  36.905 - 53.33  53.33 - 72.185 72.185 - 105.95     over 105.95  #>              25              26              29              17               5  if (run) { print(classIntervals(jenks71$jenks71, n=5, style=\"hclust\", method=\"complete\")) } #> style: hclust #>   one of 3,921,225 possible partitions of this variable into 5 classes #>   [15.57,54.81)  [54.81,74.405) [74.405,105.95)  [105.95,143.4)   [143.4,155.3]  #>              55              27              15               4               1  if (run) { print(classIntervals(jenks71$jenks71, n=5, style=\"hclust\", method=\"single\")) } #> style: hclust #>   one of 3,921,225 possible partitions of this variable into 5 classes #>  [15.57,20.995) [20.995,105.95)  [105.95,125.7)   [125.7,143.4)   [143.4,155.3]  #>               4              93               3               1               1  if (run) { set.seed(1) print(classIntervals(jenks71$jenks71, n=5, style=\"bclust\", verbose=FALSE)) } #> style: bclust #>   one of 3,921,225 possible partitions of this variable into 5 classes #>    [15.57,43.3)   [43.3,82.175) [82.175,105.95)  [105.95,143.4)   [143.4,155.3]  #>              35              53               9               4               1  if (run) { print(classIntervals(jenks71$jenks71, n=5, style=\"bclust\",  hclust.method=\"complete\", verbose=FALSE)) } #> style: bclust #>   one of 3,921,225 possible partitions of this variable into 5 classes #>    [15.57,43.3)   [43.3,82.175) [82.175,105.95)  [105.95,143.4)   [143.4,155.3]  #>              35              53               9               4               1  if (run) { print(classIntervals(jenks71$jenks71, n=5, style=\"fisher\")) } #> style: fisher #>   one of 3,921,225 possible partitions of this variable into 5 classes #>    [15.57,43.3)    [43.3,61.36)  [61.36,78.475) [78.475,105.95)  [105.95,155.3]  #>              35              33              18              11               5  if (run) { print(classIntervals(jenks71$jenks71, n=5, style=\"jenks\")) } #> style: jenks #>   one of 3,921,225 possible partitions of this variable into 5 classes #>  [15.57,41.2]  (41.2,60.66] (60.66,77.29] (77.29,100.1] (100.1,155.3]  #>            35            33            18            11             5  if (run) { print(classIntervals(jenks71$jenks71, style=\"dpih\")) } #> style: dpih #>   one of 16,007,560,800 possible partitions of this variable into 8 classes #>    [15.57,31.70792) [31.70792,47.84584) [47.84584,63.98376) [63.98376,80.12169)  #>                  14                  25                  33                  15  #> [80.12169,96.25961) [96.25961,112.3975) [112.3975,128.5355) [128.5355,144.6734]  #>                   7                   4                   2                   2  if (run) { print(classIntervals(jenks71$jenks71, style=\"dpih\", range.x=c(0, 160))) } #> style: dpih #>   one of 186,087,894,300 possible partitions of this variable into 9 classes #>        [0,16.26458) [16.26458,32.52917) [32.52917,48.79375) [48.79375,65.05834)  #>                   2                  16                  21                  34  #> [65.05834,81.32292) [81.32292,97.58751) [97.58751,113.8521) [113.8521,130.1167)  #>                  15                   8                   2                   2  #> [130.1167,146.3813]  #>                   2  if (run) {   print(classIntervals(jenks71$jenks71, style=\"headtails\")) } #> style: headtails #>   one of 100 possible partitions of this variable into 2 classes #> [15.57,56.27941) [56.27941,155.3]  #>               57               45  if (run) {   print(classIntervals(jenks71$jenks71, style=\"headtails\", thr = .45)) } #> style: headtails #>   one of 75,287,520 possible partitions of this variable into 6 classes #>    [15.57,56.27941) [56.27941,77.74533) [77.74533,100.5925)   [100.5925,126.98)  #>                  57                  29                  11                   3  #>      [126.98,143.4)       [143.4,155.3]  #>                   1                   1  if (run) {   print(classIntervals(jenks71$jenks71, style=\"maximum\")) } #> style: maximum #>   one of 16,007,560,800 possible partitions of this variable into 8 classes #> [15.57,20.995)  [20.995,43.3)   [43.3,90.16) [90.16,105.95) [105.95,114.1)  #>              4             31             58              4              1  #>  [114.1,125.7)  [125.7,143.4)  [143.4,155.3]  #>              2              1              1  if (run) {   print(classIntervals(jenks71$jenks71, style=\"box\")) } #> style: box #>   one of 75,287,520 possible partitions of this variable into 6 classes #>    [-Inf,-8.02125) [-8.02125,37.7325)    [37.7325,53.33)     [53.33,68.235)  #>                  0                 26                 25                 25  #>  [68.235,113.9887)   [113.9887,155.3]  #>                 22                  4  if (run) {   print(classIntervals(jenks71$jenks71, style=\"box\", iqr_mult = 0.25)) } #> style: box #>   one of 75,287,520 possible partitions of this variable into 6 classes #>   [15.57,30.10688) [30.10688,37.7325)    [37.7325,53.33)     [53.33,68.235)  #>                 10                 16                 25                 25  #>  [68.235,75.86062)   [75.86062,155.3]  #>                  8                 18  x <- c(0, 0, 0, 1, 2, 50) print(classIntervals(x, n=3, style=\"fisher\")) #> style: fisher #>   one of 3 possible partitions of this variable into 3 classes #>  [0,0.5) [0.5,26)  [26,50]  #>        3        2        1  print(classIntervals(x, n=3, style=\"jenks\")) #> style: jenks #>   one of 3 possible partitions of this variable into 3 classes #>  [0,0]  (0,2] (2,50]  #>      3      2      1   # Argument 'unique' will collapse the label of classes containing a # single value. This is particularly useful for 'censored' variables # that contain for example many zeros.  data_censored<-c(rep(0,10), rnorm(100, mean=20,sd=1),rep(26,10)) plot(density(data_censored))  cl2 <- classIntervals(data_censored, n=5, style=\"jenks\", dataPrecision=2) print(cl2, unique=FALSE) #> style: jenks #>   one of 4,082,925 possible partitions of this variable into 5 classes #>        [0,0]     (0,19.5] (19.5,20.63] (20.63,22.6]    (22.6,26]  #>           10           33           39           28           10  print(cl2, unique=TRUE) #> style: jenks #>   one of 4,082,925 possible partitions of this variable into 5 classes #> Class found with one single (possibly repeated) value: changed label #>            0     (0,19.5] (19.5,20.63] (20.63,22.6]           26  #>           10           33           39           28           10   if (FALSE) { # \\dontrun{ set.seed(1) n <- 1e+05 x <- runif(n) classIntervals(x, n=5, style=\"sd\") classIntervals(x, n=5, style=\"pretty\") classIntervals(x, n=5, style=\"equal\") classIntervals(x, n=5, style=\"quantile\") # the class intervals found vary a little because of sampling classIntervals(x, n=5, style=\"kmeans\") classIntervals(x, n=5, style=\"fisher\") classIntervals(x, n=5, style=\"fisher\") classIntervals(x, n=5, style=\"fisher\") } # } have_units <- FALSE if (require(units, quietly=TRUE)) have_units <- TRUE #> udunits database from /usr/share/udunits/udunits2.xml if (have_units) { set.seed(1) x_units <- set_units(sample(seq(1, 100, 0.25), 100), km/h) if (FALSE) { # \\dontrun{ classIntervals(x_units, n=5, style=\"sd\") } # } } if (have_units) { classIntervals(x_units, n=5, style=\"pretty\") } #> style: pretty #>   one of 3,764,376 possible partitions of this [km/h] variable into 5 classes #>   [0,20)  [20,40)  [40,60)  [60,80) [80,100]  #>       18       21       19       19       23  if (have_units) { if (FALSE) { # \\dontrun{ classIntervals(x_units, n=5, style=\"equal\") } # } } if (have_units) { classIntervals(x_units, n=5, style=\"quantile\") } #> style: quantile #>   one of 3,764,376 possible partitions of this [km/h] variable into 5 classes #>    [4,21.95) [21.95,41.5) [41.5,64.05) [64.05,82.8)  [82.8,99.5]  #>           20           20           20           20           20  if (have_units) { if (FALSE) { # \\dontrun{ classIntervals(x_units, n=5, style=\"kmeans\") } # } } if (have_units) { classIntervals(x_units, n=5, style=\"fisher\") } #> style: fisher #>   one of 3,764,376 possible partitions of this [km/h] variable into 5 classes #>      [4,19.375) [19.375,39.375)   [39.375,60.5)   [60.5,79.625)   [79.625,99.5]  #>              18              21              19              19              23  if (have_units) { classIntervals(x_units, style=\"headtails\") } #> style: headtails #>   one of 99 possible partitions of this [km/h] variable into 2 classes #>    [4,51.5225) [51.5225,99.5]  #>             49             51  if (have_units) { classIntervals(x_units, style=\"box\") } #> style: box #>   one of 71,523,144 possible partitions of this [km/h] variable into 6 classes #>    [-Inf,-46.375) [-46.375,26.9375)      [26.9375,52)      [52,75.8125)  #>                 0                25                25                25  #> [75.8125,149.125)     [149.125,Inf]  #>                25                 0  if (FALSE) { # \\dontrun{ st <- Sys.time() x_POSIXt <- sample(st+((0:500)*3600), 100) fx <- st+((0:5)*3600)*100 classIntervals(x_POSIXt, style=\"fixed\", fixedBreaks=fx) classIntervals(x_POSIXt, n=5, style=\"sd\") classIntervals(x_POSIXt, n=5, style=\"pretty\") classIntervals(x_POSIXt, n=5, style=\"equal\") classIntervals(x_POSIXt, n=5, style=\"quantile\") classIntervals(x_POSIXt, n=5, style=\"kmeans\") classIntervals(x_POSIXt, n=5, style=\"fisher\") classIntervals(x_POSIXt, style=\"headtails\") classIntervals(x_POSIXt, style=\"maximum\") classIntervals(x_POSIXt, style=\"box\") } # } # see vignette for further details if (FALSE) { # \\dontrun{ # Head Tails method is suitable for right-sided heavy-tailed distributions set.seed(1234) # Heavy tails----- # Pareto distributions a=7 b=14 paretodist <- 7 / (1 - runif(100)) ^ (1 / 14) # Lognorm lognormdist <- rlnorm(100) # Weibull weibulldist <- rweibull(100, 1, scale = 5)  pal1 <- c(\"wheat1\", \"red3\") opar <- par(mfrow = c(1, 3)) plot(classIntervals(paretodist, style = \"headtails\"),      pal = pal1,      main = \"HeadTails: Pareto Dist.\") plot(classIntervals(lognormdist, style = \"headtails\"),      pal = pal1,      main = \"HeadTails: LogNormal Dist.\") plot(classIntervals(weibulldist, style = \"headtails\"),      pal = pal1,      main = \"HeadTails: Weibull Dist.\") plot(classIntervals(paretodist, n = 5, style = \"fisher\"),      pal = pal1,      main = \"Fisher: Pareto Dist.\") plot(classIntervals(lognormdist, n = 7, style = \"fisher\"),      pal = pal1,      main = \"Fisher: LogNormal Dist.\") plot(classIntervals(weibulldist, n= 4, style = \"fisher\"),      pal = pal1,      main = \"Fisher: Weibull Dist.\") par(opar)   #Non heavy tails, thr should be increased-----  #Normal dist normdist <- rnorm(100) #Left-tailed truncated Normal distr leftnorm <- rep(normdist[normdist < mean(normdist)], 2) # Uniform distribution unifdist <- runif(100) opar <- par(mfrow = c(2, 3)) plot(classIntervals(normdist, style = \"headtails\"),      pal = pal1,      main = \"Normal Dist.\") plot(classIntervals(leftnorm, style = \"headtails\"),      pal = pal1,      main = \"Truncated Normal Dist.\") plot(classIntervals(unifdist, style = \"headtails\"),      pal = pal1,      main = \"Uniform Dist.\") # thr should be increased for non heavy-tailed distributions plot(   classIntervals(normdist, style = \"headtails\", thr = .6),   pal = pal1,   main = \"Normal Dist. thr = .6\" ) plot(   classIntervals(leftnorm, style = \"headtails\", thr = .6),   pal = pal1,   main = \"Truncated Normal Distribution thr = .6\" ) plot(   classIntervals(unifdist, style = \"headtails\", thr = .6),   pal = pal1,   main = \"Uniform Distribution thr = .6\" ) par(opar) } # }"},{"path":"https://r-spatial.github.io/classInt/reference/classify_intervals.html","id":null,"dir":"Reference","previous_headings":"","what":"Classify univariate vector to interval — Classify Intervals","title":"Classify univariate vector to interval — Classify Intervals","text":"Given numeric vector classify numeric intervals. classify_intervals() wrapper classIntervals() findCols().","code":""},{"path":"https://r-spatial.github.io/classInt/reference/classify_intervals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Classify univariate vector to interval — Classify Intervals","text":"","code":"classify_intervals(var, n, style = \"quantile\", rtimes = 3, ...,  intervalClosure = c(\"left\", \"right\"), dataPrecision = NULL,  warnSmallN = TRUE, warnLargeN = TRUE, largeN = 3000L, samp_prop = 0.1,  gr = c(\"[\", \"]\"), factor = TRUE)"},{"path":"https://r-spatial.github.io/classInt/reference/classify_intervals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Classify univariate vector to interval — Classify Intervals","text":"var continuous numerical variable n number classes required, missing, nclass.Sturges used; see also \"dpih\" \"headtails\" styles automatic choice number classes style chosen style: one \"fixed\", \"sd\", \"equal\", \"pretty\", \"quantile\", \"kmeans\", \"hclust\", \"bclust\", \"fisher\", \"jenks\", \"dpih\", \"headtails\", \"maximum\" rtimes number replications var catenate jitter; may used styles \"kmeans\" \"bclust\" case difficulties reaching classification intervalClosure default “left”,  allows specification whether partition intervals closed left right (added Richard Dunlap). Note sense interval closure hard-coded “right”-closed whenstyle=\"jenks\" (see Details ). dataPrecision default NULL, permits rounding interval endpoints (added Richard Dunlap). data precision used printing interval values legend returned findColours, print method classIntervals objects. intervalClosure “left”, value returned ceiling data value multiplied 10 dataPrecision power, divided 10 dataPrecision power. argument round var, input variable. warnSmallN default TRUE, FALSE, quietens warning n >= nobs warnLargeN default TRUE, FALSE large data handling used largeN default 3000L, QGIS sampling threshold; 3000, observations presented \"fisher\" \"jenks\" either samp_prop= sample sample 3000, whichever larger samp_prop default 0.1, QGIS 10% sampling proportion gr default c(\"[\", \"]\"), units package available, units::units_options(\"group\") may used directly give enclosing bracket style ... arguments passed functions called style factor default \"TRUE\", \"TRUE\" returns cols factor intervals labels rather integers","code":""},{"path":"https://r-spatial.github.io/classInt/reference/classify_intervals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Classify univariate vector to interval — Classify Intervals","text":"vector length var. factor = FALSE returns factor levels interval observation.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/classInt/reference/classify_intervals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Classify univariate vector to interval — Classify Intervals","text":"","code":"xvar <- c(22361, 9573, 4836, 5309, 10384, 4359, 11016, 4414, 3327, 3408,    17816, 6909, 6936, 7990, 3758, 3569, 21965, 3605, 2181, 1892,    2459, 2934, 6399, 8578, 8537, 4840, 12132, 3734, 4372, 9073,    7508, 5203) classIntervals(xvar, 5, \"sd\") #> style: sd #>   one of 31,465 possible partitions of this variable into 5 classes #> [-3179.375,2025.578)  [2025.578,7230.531)  [7230.531,12435.48)  #>                    1                   19                    9  #>  [12435.48,17640.44)  [17640.44,22845.39]  #>                    0                    3  classify_intervals(xvar, 5, \"sd\", factor = FALSE) #>  [1] 5 3 2 2 3 2 3 2 2 2 5 2 2 3 2 2 5 2 2 1 2 2 2 3 3 2 3 2 2 3 3 2 classify_intervals(xvar, 5, \"sd\", factor = TRUE) #>  [1] [17640.44,22845.39]  [7230.531,12435.48)  [2025.578,7230.531)  #>  [4] [2025.578,7230.531)  [7230.531,12435.48)  [2025.578,7230.531)  #>  [7] [7230.531,12435.48)  [2025.578,7230.531)  [2025.578,7230.531)  #> [10] [2025.578,7230.531)  [17640.44,22845.39]  [2025.578,7230.531)  #> [13] [2025.578,7230.531)  [7230.531,12435.48)  [2025.578,7230.531)  #> [16] [2025.578,7230.531)  [17640.44,22845.39]  [2025.578,7230.531)  #> [19] [2025.578,7230.531)  [-3179.375,2025.578) [2025.578,7230.531)  #> [22] [2025.578,7230.531)  [2025.578,7230.531)  [7230.531,12435.48)  #> [25] [7230.531,12435.48)  [2025.578,7230.531)  [7230.531,12435.48)  #> [28] [2025.578,7230.531)  [2025.578,7230.531)  [7230.531,12435.48)  #> [31] [7230.531,12435.48)  [2025.578,7230.531)  #> 5 Levels: [-3179.375,2025.578) [2025.578,7230.531) ... [17640.44,22845.39]  if (!require(\"spData\", quietly=TRUE)) {   message(\"spData package needed for examples\")   run <- FALSE } else {   run <- TRUE }  if (run) {   data(\"jenks71\", package = \"spData\")   x <- jenks71$jenks71   classify_intervals(x, n = 5, style = \"fisher\") } #>   [1] [43.3,61.36)    [78.475,105.95) [61.36,78.475)  [61.36,78.475)  #>   [5] [78.475,105.95) [78.475,105.95) [78.475,105.95) [78.475,105.95) #>   [9] [105.95,155.3]  [105.95,155.3]  [105.95,155.3]  [105.95,155.3]  #>  [13] [78.475,105.95) [78.475,105.95) [61.36,78.475)  [78.475,105.95) #>  [17] [61.36,78.475)  [61.36,78.475)  [78.475,105.95) [105.95,155.3]  #>  [21] [43.3,61.36)    [61.36,78.475)  [61.36,78.475)  [61.36,78.475)  #>  [25] [78.475,105.95) [61.36,78.475)  [61.36,78.475)  [43.3,61.36)    #>  [29] [61.36,78.475)  [78.475,105.95) [43.3,61.36)    [43.3,61.36)    #>  [33] [43.3,61.36)    [61.36,78.475)  [61.36,78.475)  [61.36,78.475)  #>  [37] [43.3,61.36)    [43.3,61.36)    [61.36,78.475)  [43.3,61.36)    #>  [41] [15.57,43.3)    [43.3,61.36)    [43.3,61.36)    [15.57,43.3)    #>  [45] [43.3,61.36)    [61.36,78.475)  [43.3,61.36)    [61.36,78.475)  #>  [49] [43.3,61.36)    [15.57,43.3)    [43.3,61.36)    [61.36,78.475)  #>  [53] [43.3,61.36)    [43.3,61.36)    [43.3,61.36)    [43.3,61.36)    #>  [57] [43.3,61.36)    [43.3,61.36)    [43.3,61.36)    [43.3,61.36)    #>  [61] [43.3,61.36)    [43.3,61.36)    [43.3,61.36)    [43.3,61.36)    #>  [65] [15.57,43.3)    [15.57,43.3)    [43.3,61.36)    [43.3,61.36)    #>  [69] [15.57,43.3)    [15.57,43.3)    [15.57,43.3)    [15.57,43.3)    #>  [73] [43.3,61.36)    [43.3,61.36)    [15.57,43.3)    [15.57,43.3)    #>  [77] [15.57,43.3)    [15.57,43.3)    [43.3,61.36)    [43.3,61.36)    #>  [81] [15.57,43.3)    [15.57,43.3)    [15.57,43.3)    [15.57,43.3)    #>  [85] [15.57,43.3)    [15.57,43.3)    [15.57,43.3)    [15.57,43.3)    #>  [89] [15.57,43.3)    [15.57,43.3)    [15.57,43.3)    [15.57,43.3)    #>  [93] [15.57,43.3)    [15.57,43.3)    [15.57,43.3)    [15.57,43.3)    #>  [97] [15.57,43.3)    [15.57,43.3)    [15.57,43.3)    [15.57,43.3)    #> [101] [15.57,43.3)    [15.57,43.3)    #> 5 Levels: [15.57,43.3) [43.3,61.36) [61.36,78.475) ... [105.95,155.3]"},{"path":"https://r-spatial.github.io/classInt/reference/findColours.html","id":null,"dir":"Reference","previous_headings":"","what":"assign colours to classes from classInterval object — findColours","title":"assign colours to classes from classInterval object — findColours","text":"helper function wrapper findCols extract classes \"classInterval\" object assign colours palette created colorRampPalette two colours given pal argument. also returns two attributes use constructing legend.","code":""},{"path":"https://r-spatial.github.io/classInt/reference/findColours.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"assign colours to classes from classInterval object — findColours","text":"","code":"findColours(clI, pal, under=\"under\", over=\"over\", between=\"-\",   digits = getOption(\"digits\"), cutlabels=TRUE)"},{"path":"https://r-spatial.github.io/classInt/reference/findColours.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"assign colours to classes from classInterval object — findColours","text":"clI \"classIntervals\" object pal character vector least two colour names; colorRampPalette used internally create required number colours character string value \"\" legend cutlabels=FALSE character string value \"\" legend cutlabels=FALSE character string value \"\" legend cutlabels=FALSE digits minimal number significant digits legend cutlabels use cut-style labels legend","code":""},{"path":"https://r-spatial.github.io/classInt/reference/findColours.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"assign colours to classes from classInterval object — findColours","text":"character vector colours attributes: \"table\", named frequency table; \"palette\", character vector colours corresponding specified breaks.","code":""},{"path":"https://r-spatial.github.io/classInt/reference/findColours.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"assign colours to classes from classInterval object — findColours","text":"Roger Bivand <Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/classInt/reference/findColours.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"assign colours to classes from classInterval object — findColours","text":"","code":"if (!require(\"spData\", quietly=TRUE)) {   message(\"spData package needed for examples\")   run <- FALSE } else {   run <- TRUE } if (run) { data(jenks71, package=\"spData\") mypal <- c(\"wheat1\", \"red3\") h5 <- classIntervals(jenks71$jenks71, n=5, style=\"hclust\", method=\"complete\") print(findColours(h5, mypal)) } #>   [1] \"#FFE7BA\" \"#E6735D\" \"#E6735D\" \"#F2AD8B\" \"#E6735D\" \"#E6735D\" \"#E6735D\" #>   [8] \"#E6735D\" \"#D9392E\" \"#CD0000\" \"#D9392E\" \"#D9392E\" \"#E6735D\" \"#E6735D\" #>  [15] \"#F2AD8B\" \"#E6735D\" \"#E6735D\" \"#E6735D\" \"#E6735D\" \"#D9392E\" \"#F2AD8B\" #>  [22] \"#E6735D\" \"#F2AD8B\" \"#F2AD8B\" \"#E6735D\" \"#F2AD8B\" \"#F2AD8B\" \"#F2AD8B\" #>  [29] \"#F2AD8B\" \"#E6735D\" \"#F2AD8B\" \"#FFE7BA\" \"#F2AD8B\" \"#F2AD8B\" \"#F2AD8B\" #>  [36] \"#F2AD8B\" \"#FFE7BA\" \"#FFE7BA\" \"#F2AD8B\" \"#F2AD8B\" \"#FFE7BA\" \"#F2AD8B\" #>  [43] \"#F2AD8B\" \"#FFE7BA\" \"#F2AD8B\" \"#F2AD8B\" \"#FFE7BA\" \"#F2AD8B\" \"#FFE7BA\" #>  [50] \"#FFE7BA\" \"#F2AD8B\" \"#F2AD8B\" \"#FFE7BA\" \"#F2AD8B\" \"#F2AD8B\" \"#FFE7BA\" #>  [57] \"#F2AD8B\" \"#F2AD8B\" \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" #>  [64] \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" #>  [71] \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" #>  [78] \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" #>  [85] \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" #>  [92] \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" #>  [99] \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" #> attr(,\"palette\") #> [1] \"#FFE7BA\" \"#F2AD8B\" \"#E6735D\" \"#D9392E\" \"#CD0000\" #> attr(,\"table\") #>   [15.57,54.81)  [54.81,74.405) [74.405,105.95)  [105.95,143.4)   [143.4,155.3]  #>              55              27              15               4               1  if (run) { print(findColours(getHclustClassIntervals(h5, k=7), mypal)) } #>   [1] \"#F6C09B\" \"#E6735D\" \"#E6735D\" \"#EE9A7C\" \"#E6735D\" \"#E6735D\" \"#E6735D\" #>   [8] \"#DD4D3E\" \"#D5261F\" \"#CD0000\" \"#D5261F\" \"#D5261F\" \"#DD4D3E\" \"#E6735D\" #>  [15] \"#EE9A7C\" \"#DD4D3E\" \"#E6735D\" \"#E6735D\" \"#E6735D\" \"#D5261F\" \"#EE9A7C\" #>  [22] \"#E6735D\" \"#EE9A7C\" \"#EE9A7C\" \"#E6735D\" \"#EE9A7C\" \"#EE9A7C\" \"#EE9A7C\" #>  [29] \"#EE9A7C\" \"#DD4D3E\" \"#EE9A7C\" \"#F6C09B\" \"#EE9A7C\" \"#EE9A7C\" \"#EE9A7C\" #>  [36] \"#EE9A7C\" \"#F6C09B\" \"#F6C09B\" \"#EE9A7C\" \"#EE9A7C\" \"#F6C09B\" \"#EE9A7C\" #>  [43] \"#EE9A7C\" \"#F6C09B\" \"#EE9A7C\" \"#EE9A7C\" \"#F6C09B\" \"#EE9A7C\" \"#F6C09B\" #>  [50] \"#F6C09B\" \"#EE9A7C\" \"#EE9A7C\" \"#F6C09B\" \"#EE9A7C\" \"#EE9A7C\" \"#F6C09B\" #>  [57] \"#EE9A7C\" \"#EE9A7C\" \"#F6C09B\" \"#F6C09B\" \"#F6C09B\" \"#F6C09B\" \"#F6C09B\" #>  [64] \"#F6C09B\" \"#F6C09B\" \"#F6C09B\" \"#F6C09B\" \"#F6C09B\" \"#F6C09B\" \"#F6C09B\" #>  [71] \"#F6C09B\" \"#F6C09B\" \"#F6C09B\" \"#F6C09B\" \"#F6C09B\" \"#F6C09B\" \"#F6C09B\" #>  [78] \"#F6C09B\" \"#F6C09B\" \"#F6C09B\" \"#F6C09B\" \"#F6C09B\" \"#F6C09B\" \"#F6C09B\" #>  [85] \"#F6C09B\" \"#F6C09B\" \"#F6C09B\" \"#FFE7BA\" \"#F6C09B\" \"#FFE7BA\" \"#FFE7BA\" #>  [92] \"#F6C09B\" \"#F6C09B\" \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" \"#F6C09B\" \"#FFE7BA\" #>  [99] \"#FFE7BA\" \"#FFE7BA\" \"#FFE7BA\" \"#F6C09B\" #> attr(,\"palette\") #> [1] \"#FFE7BA\" \"#F6C09B\" \"#EE9A7C\" \"#E6735D\" \"#DD4D3E\" \"#D5261F\" \"#CD0000\" #> attr(,\"table\") #>  [15.57,29.84)  [29.84,54.81) [54.81,74.405) [74.405,90.16) [90.16,105.95)  #>             10             45             27             11              4  #> [105.95,143.4)  [143.4,155.3]  #>              4              1  if (run) { h5Colours <- findColours(h5, mypal) plot(h5, mypal, main=\"Complete hierarchical clustering\") legend(c(95, 155), c(0.12, 0.4), fill=attr(h5Colours, \"palette\"),  legend=names(attr(h5Colours, \"table\")), bg=\"white\") }  if (run) { h5tab <- attr(h5Colours, \"table\") legtext <- paste(names(h5tab), \" (\", h5tab, \")\", sep=\"\") plot(h5, mypal, main=\"Complete hierarchical clustering (with counts)\") legend(c(95, 165), c(0.12, 0.4), fill=attr(h5Colours, \"palette\"),  legend=legtext, bg=\"white\") }"},{"path":"https://r-spatial.github.io/classInt/reference/findCols.html","id":null,"dir":"Reference","previous_headings":"","what":"extract classes from classInterval object — findCols","title":"extract classes from classInterval object — findCols","text":"helper function wrapper findInterval extract classes \"classInterval\" object","code":""},{"path":"https://r-spatial.github.io/classInt/reference/findCols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"extract classes from classInterval object — findCols","text":"","code":"findCols(clI, factor = FALSE)"},{"path":"https://r-spatial.github.io/classInt/reference/findCols.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"extract classes from classInterval object — findCols","text":"clI \"classIntervals\" object factor default \"FALSE\", \"TRUE\" returns cols factor intervals labels","code":""},{"path":"https://r-spatial.github.io/classInt/reference/findCols.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"extract classes from classInterval object — findCols","text":"integer vector class indices","code":""},{"path":"https://r-spatial.github.io/classInt/reference/findCols.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"extract classes from classInterval object — findCols","text":"Roger Bivand <Roger.Bivand@nhh.>","code":""},{"path":[]},{"path":"https://r-spatial.github.io/classInt/reference/findCols.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"extract classes from classInterval object — findCols","text":"","code":"xvar <- c(22361, 9573, 4836, 5309, 10384, 4359, 11016, 4414, 3327, 3408,    17816, 6909, 6936, 7990, 3758, 3569, 21965, 3605, 2181, 1892,    2459, 2934, 6399, 8578, 8537, 4840, 12132, 3734, 4372, 9073,    7508, 5203) findCols(classIntervals(xvar, 5, \"sd\"), factor = FALSE) #>  [1] 5 3 2 2 3 2 3 2 2 2 5 2 2 3 2 2 5 2 2 1 2 2 2 3 3 2 3 2 2 3 3 2 findCols(classIntervals(xvar, 5, \"sd\"), factor = TRUE) #>  [1] [17640.44,22845.39]  [7230.531,12435.48)  [2025.578,7230.531)  #>  [4] [2025.578,7230.531)  [7230.531,12435.48)  [2025.578,7230.531)  #>  [7] [7230.531,12435.48)  [2025.578,7230.531)  [2025.578,7230.531)  #> [10] [2025.578,7230.531)  [17640.44,22845.39]  [2025.578,7230.531)  #> [13] [2025.578,7230.531)  [7230.531,12435.48)  [2025.578,7230.531)  #> [16] [2025.578,7230.531)  [17640.44,22845.39]  [2025.578,7230.531)  #> [19] [2025.578,7230.531)  [-3179.375,2025.578) [2025.578,7230.531)  #> [22] [2025.578,7230.531)  [2025.578,7230.531)  [7230.531,12435.48)  #> [25] [7230.531,12435.48)  [2025.578,7230.531)  [7230.531,12435.48)  #> [28] [2025.578,7230.531)  [2025.578,7230.531)  [7230.531,12435.48)  #> [31] [7230.531,12435.48)  [2025.578,7230.531)  #> 5 Levels: [-3179.375,2025.578) [2025.578,7230.531) ... [17640.44,22845.39] if (!require(\"spData\", quietly=TRUE)) {   message(\"spData package needed for examples\")   run <- FALSE } else {   run <- TRUE } if (run) { data(jenks71, package=\"spData\") fix5 <- classIntervals(jenks71$jenks71, n=5, style=\"fixed\",  fixedBreaks=c(15.57, 25, 50, 75, 100, 155.30)) print(fix5) } #> style: fixed #>   one of 3,921,225 possible partitions of this variable into 5 classes #>  [15.57,25)     [25,50)     [50,75)    [75,100) [100,155.3]  #>           6          34          42          14           6  if (run) { print(findCols(fix5)) print(findCols(fix5, factor = TRUE)) } #>   [1] 3 4 4 3 4 4 4 4 5 5 5 5 4 4 3 4 4 4 4 5 3 4 3 3 4 3 3 3 3 5 3 3 3 3 3 3 3 #>  [38] 3 3 3 2 3 3 2 3 3 2 3 3 2 3 3 3 3 3 3 3 3 2 3 2 3 3 3 2 2 3 3 2 2 2 2 2 3 #>  [75] 2 2 2 2 3 2 2 2 2 2 2 2 2 2 2 1 2 2 2 2 1 1 2 1 1 1 2 2 #>   [1] [50,75)     [75,100)    [75,100)    [50,75)     [75,100)    [75,100)    #>   [7] [75,100)    [75,100)    [100,155.3] [100,155.3] [100,155.3] [100,155.3] #>  [13] [75,100)    [75,100)    [50,75)     [75,100)    [75,100)    [75,100)    #>  [19] [75,100)    [100,155.3] [50,75)     [75,100)    [50,75)     [50,75)     #>  [25] [75,100)    [50,75)     [50,75)     [50,75)     [50,75)     [100,155.3] #>  [31] [50,75)     [50,75)     [50,75)     [50,75)     [50,75)     [50,75)     #>  [37] [50,75)     [50,75)     [50,75)     [50,75)     [25,50)     [50,75)     #>  [43] [50,75)     [25,50)     [50,75)     [50,75)     [25,50)     [50,75)     #>  [49] [50,75)     [25,50)     [50,75)     [50,75)     [50,75)     [50,75)     #>  [55] [50,75)     [50,75)     [50,75)     [50,75)     [25,50)     [50,75)     #>  [61] [25,50)     [50,75)     [50,75)     [50,75)     [25,50)     [25,50)     #>  [67] [50,75)     [50,75)     [25,50)     [25,50)     [25,50)     [25,50)     #>  [73] [25,50)     [50,75)     [25,50)     [25,50)     [25,50)     [25,50)     #>  [79] [50,75)     [25,50)     [25,50)     [25,50)     [25,50)     [25,50)     #>  [85] [25,50)     [25,50)     [25,50)     [25,50)     [25,50)     [15.57,25)  #>  [91] [25,50)     [25,50)     [25,50)     [25,50)     [15.57,25)  [15.57,25)  #>  [97] [25,50)     [15.57,25)  [15.57,25)  [15.57,25)  [25,50)     [25,50)     #> Levels: [15.57,25) [25,50) [50,75) [75,100) [100,155.3]"},{"path":"https://r-spatial.github.io/classInt/reference/getBclustClassIntervals.html","id":null,"dir":"Reference","previous_headings":"","what":"Change breaks in a ","title":"Change breaks in a ","text":"\"classIntervals\" objects style \"hclust\" \"bclust\" contain hierarchical classification trees \"par\" attribute, different numbers classes can chosen without repeating initial classification. function accesses \"par\" attribute modifies \"brks\" member returned \"classIntervals\" object.","code":""},{"path":"https://r-spatial.github.io/classInt/reference/getBclustClassIntervals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Change breaks in a ","text":"","code":"getBclustClassIntervals(clI, k) getHclustClassIntervals(clI, k)"},{"path":"https://r-spatial.github.io/classInt/reference/getBclustClassIntervals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Change breaks in a ","text":"clI \"classIntervals\" object k number classes required","code":""},{"path":"https://r-spatial.github.io/classInt/reference/getBclustClassIntervals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Change breaks in a ","text":"\"classIntervals\" object \"modified\" attribute set","code":""},{"path":"https://r-spatial.github.io/classInt/reference/getBclustClassIntervals.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Change breaks in a ","text":"Roger Bivand <Roger.Bivand@nhh.>","code":""},{"path":[]},{"path":"https://r-spatial.github.io/classInt/reference/getBclustClassIntervals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Change breaks in a ","text":"","code":"if (!require(\"spData\", quietly=TRUE)) {   message(\"spData package needed for examples\")   run <- FALSE } else {   run <- TRUE } if (run) { data(jenks71, package=\"spData\") pal1 <- c(\"wheat1\", \"red3\") opar <- par(mfrow=c(2,2)) hCI5 <- classIntervals(jenks71$jenks71, n=5, style=\"hclust\", method=\"complete\") plot(attr(hCI5, \"par\")) plot(hCI5, pal=pal1, main=\"hclust k=5\") plot(getHclustClassIntervals(hCI5, k=7), pal=pal1, main=\"hclust k=7\") plot(getHclustClassIntervals(hCI5, k=9), pal=pal1, main=\"hclust k=9\") par(opar) }  if (run) { set.seed(1) bCI5 <- classIntervals(jenks71$jenks71, n=5, style=\"bclust\") plot(attr(bCI5, \"par\")) } #> Committee Member: 1(1) 2(1) 3(1) 4(1) 5(1) 6(1) 7(1) 8(1) 9(1) 10(1) #> Computing Hierarchical Clustering  if (run) { opar <- par(mfrow=c(2,2)) plot(getBclustClassIntervals(bCI5, k=3), pal=pal1, main=\"bclust k=3\") plot(bCI5, pal=pal1, main=\"bclust k=5\") plot(getBclustClassIntervals(bCI5, k=7), pal=pal1, main=\"bclust k=7\") plot(getBclustClassIntervals(bCI5, k=9), pal=pal1, main=\"bclust k=9\") par(opar) }"},{"path":"https://r-spatial.github.io/classInt/reference/jenks.tests.html","id":null,"dir":"Reference","previous_headings":"","what":"Indices for assessing class intervals — jenks.tests","title":"Indices for assessing class intervals — jenks.tests","text":"function returns values two indices assessing class intervals: goodness variance fit measure, tabular accuracy index; optionally overview accuracy index also returned area argument missing.","code":""},{"path":"https://r-spatial.github.io/classInt/reference/jenks.tests.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Indices for assessing class intervals — jenks.tests","text":"","code":"jenks.tests(clI, area)"},{"path":"https://r-spatial.github.io/classInt/reference/jenks.tests.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Indices for assessing class intervals — jenks.tests","text":"clI \"classIntervals\" object area optional vector object areas overview accuracy index also required","code":""},{"path":"https://r-spatial.github.io/classInt/reference/jenks.tests.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Indices for assessing class intervals — jenks.tests","text":"goodness variance fit measure given Armstrong et al. (2003, p. 600) : $$GVF = 1 - \\frac{\\sum_{j=1}^{k}\\sum_{=1}^{N_j}{(z_{ij} - \\bar{z}_j)}^2}{\\sum_{=1}^{N}{(z_{} - \\bar{z})}^2}$$ \\(z_{}, =1,\\ldots,N\\) observed values, \\(k\\) number classes, \\(\\bar{z}_j\\) class mean class \\(j\\), \\(N_j\\) number counties class \\(j\\). tabular accuracy index given Armstrong et al. (2003, p. 600) : $$TAI = 1 - \\frac{\\sum_{j=1}^{k}\\sum_{=1}^{N_j}{|z_{ij} - \\bar{z}_j|}}{\\sum_{=1}^{N}{|z_{} - \\bar{z}|}}$$ overview accuracy index polygon observations known areas given Armstrong et al. (2003, p. 600) : $$OAI = 1 - \\frac{\\sum_{j=1}^{k}\\sum_{=1}^{N_j}{|z_{ij} - \\bar{z}_j| a_{ij}}}{\\sum_{=1}^{N}{|z_{} - \\bar{z}| a_i}}$$ \\(a_i, =1,\\ldots,N\\) polygon areas, \\(a_{ij}\\) term indexed \\(j=1,\\ldots,k\\) classes, \\(=1,\\ldots,N_j\\) polygons class \\(j\\).","code":""},{"path":"https://r-spatial.github.io/classInt/reference/jenks.tests.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Indices for assessing class intervals — jenks.tests","text":"named vector index values","code":""},{"path":"https://r-spatial.github.io/classInt/reference/jenks.tests.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Indices for assessing class intervals — jenks.tests","text":"Armstrong, M. P., Xiao, N., Bennett, D. ., 2003. \"Using genetic algorithms create multicriteria class intervals choropleth maps\". Annals, Association American Geographers, 93 (3), 595–623; Jenks, G. F., Caspall, F. C., 1971. \"Error choroplethic maps: definition, measurement, reduction\". Annals, Association American Geographers, 61 (2), 217–244","code":""},{"path":"https://r-spatial.github.io/classInt/reference/jenks.tests.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Indices for assessing class intervals — jenks.tests","text":"Roger Bivand <Roger.Bivand@nhh.>","code":""},{"path":[]},{"path":"https://r-spatial.github.io/classInt/reference/jenks.tests.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Indices for assessing class intervals — jenks.tests","text":"","code":"if (!require(\"spData\", quietly=TRUE)) {   message(\"spData package needed for examples\")   run <- FALSE } else {   run <- TRUE } if (run) { data(jenks71, package=\"spData\") fix5 <- classIntervals(jenks71$jenks71, n=5, style=\"fixed\",  fixedBreaks=c(15.57, 25, 50, 75, 100, 155.30)) print(jenks.tests(fix5, jenks71$area)) } #>         # classes   Goodness of fit  Tabular accuracy Overview accuracy  #>         5.0000000         0.9107081         0.6879834         0.6617187  if (run) { q5 <- classIntervals(jenks71$jenks71, n=5, style=\"quantile\") print(jenks.tests(q5, jenks71$area)) } #>         # classes   Goodness of fit  Tabular accuracy Overview accuracy  #>         5.0000000         0.8329466         0.6654742         0.6280755  if (run) { set.seed(1) k5 <- classIntervals(jenks71$jenks71, n=5, style=\"kmeans\") print(jenks.tests(k5, jenks71$area)) } #>         # classes   Goodness of fit  Tabular accuracy Overview accuracy  #>         5.0000000         0.9253431         0.7067202         0.6974831  if (run) { h5 <- classIntervals(jenks71$jenks71, n=5, style=\"hclust\", method=\"complete\") print(jenks.tests(h5, jenks71$area)) } #>         # classes   Goodness of fit  Tabular accuracy Overview accuracy  #>         5.0000000         0.8705880         0.6098086         0.6099738  if (run) { print(jenks.tests(getHclustClassIntervals(h5, k=7), jenks71$area)) } #>         # classes   Goodness of fit  Tabular accuracy Overview accuracy  #>         7.0000000         0.9298169         0.6951671         0.6851124  if (run) { print(jenks.tests(getHclustClassIntervals(h5, k=9), jenks71$area)) } #>         # classes   Goodness of fit  Tabular accuracy Overview accuracy  #>         9.0000000         0.9720995         0.8134540         0.8106422  if (run) { set.seed(1) b5 <- classIntervals(jenks71$jenks71, n=5, style=\"bclust\") print(jenks.tests(b5, jenks71$area)) } #> Committee Member: 1(1) 2(1) 3(1) 4(1) 5(1) 6(1) 7(1) 8(1) 9(1) 10(1) #> Computing Hierarchical Clustering #>         # classes   Goodness of fit  Tabular accuracy Overview accuracy  #>         5.0000000         0.8926083         0.6481529         0.6451755  if (run) { print(jenks.tests(getBclustClassIntervals(b5, k=7), jenks71$area)) } #>         # classes   Goodness of fit  Tabular accuracy Overview accuracy  #>         7.0000000         0.9642511         0.7833643         0.7759815  if (run) { print(jenks.tests(getBclustClassIntervals(b5, k=9), jenks71$area)) } #>         # classes   Goodness of fit  Tabular accuracy Overview accuracy  #>         9.0000000         0.9708970         0.8081457         0.8034682"},{"path":"https://r-spatial.github.io/classInt/reference/logLik.classIntervals.html","id":null,"dir":"Reference","previous_headings":"","what":"Log-likelihood for classIntervals objects — logLik.classIntervals","title":"Log-likelihood for classIntervals objects — logLik.classIntervals","text":"Log-likelihood classIntervals objects","code":""},{"path":"https://r-spatial.github.io/classInt/reference/logLik.classIntervals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log-likelihood for classIntervals objects — logLik.classIntervals","text":"","code":"# S3 method for class 'classIntervals' logLik(object, ...)"},{"path":"https://r-spatial.github.io/classInt/reference/logLik.classIntervals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log-likelihood for classIntervals objects — logLik.classIntervals","text":"object classIntervals object ... Ignored.","code":""},{"path":"https://r-spatial.github.io/classInt/reference/logLik.classIntervals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log-likelihood for classIntervals objects — logLik.classIntervals","text":"`logLik` object (see `stats::logLik`).","code":""},{"path":"https://r-spatial.github.io/classInt/reference/logLik.classIntervals.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Log-likelihood for classIntervals objects — logLik.classIntervals","text":"Generally, likelihood method minimizing standard deviation within interval, AIC, per-interval penalty can used maximize information self-similarity data interval. Based Birge 2006 Davies 2009 (see references), interval binning selections may compared likelihood optimize number intervals selected set data.  `logLik()` function (associated `AIC()` function) can used optimize binning maximizing likelihood across choices intervals. illustrated examples (AIC comparison specifically select 3 intervals comparing 2, 3, 4 intervals data 3 intervals), likelihood-based methods can provide evidence toward optimization binning, infallible bin selection.","code":""},{"path":"https://r-spatial.github.io/classInt/reference/logLik.classIntervals.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Log-likelihood for classIntervals objects — logLik.classIntervals","text":"Lucien Birge, Yves Rozenholc.  many bins put regular histogram.  ESAIM: Probability Statistics. 31 January 2006. 10:24-45. url: https://www.esaim-ps.org/articles/ps/abs/2006/01/ps0322/ps0322.html. doi:10.1051/ps:2006001 Laurie Davies, Ursula Gather, Dan Nordman, Henrike Weinert. comparison automatic histogram constructions. ESAIM: Probability Statistics. \t11 June 2009.  13:181-196. url: https://www.esaim-ps.org/articles/ps/abs/2009/01/ps0721/ps0721.html doi:10.1051/ps:2008005","code":""},{"path":"https://r-spatial.github.io/classInt/reference/logLik.classIntervals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Log-likelihood for classIntervals objects — logLik.classIntervals","text":"","code":"x <- classIntervals(rnorm(100), n=5, style=\"fisher\") logLik(x) #> 'log Lik.' 8.000225 (df=5) AIC(x) # By having a logLik method, AIC.default is used. #> [1] -6.00045  # When the intervals are made of a limited number of discrete values, the # logLik is zero by definition (the standard deviation is zero giving a dirac # function at the discrete value indicating a density of 1 and a log-density # of zero). x <- classIntervals(rep(1:2, each=10), n=2, style=\"jenks\") #> Warning: n same as number of different finite values\\neach different finite value is a separate class logLik(x) #> 'log Lik.' 0 (df=2) x <- classIntervals(rep(1:3, each=10), n=2, style=\"jenks\") logLik(x) #> 'log Lik.' -14.52876 (df=2)  # With slight jitter but notable categorical intervals (at 1, 2, and 3), the # AIC will make selection of the optimal intervals easier. data <- rep(1:3, each=100) + runif(n=300, min=-0.01, max=0.01) x_2 <- classIntervals(data, n=2, style=\"jenks\") x_3 <- classIntervals(data, n=3, style=\"jenks\") x_4 <- classIntervals(data, n=4, style=\"jenks\") AIC(x_2, x_3, x_4) #>     df        AIC #> x_2  2  -456.1001 #> x_3  3 -2237.4472 #> x_4  4 -2384.8774"},{"path":"https://r-spatial.github.io/classInt/news/index.html","id":"version-04-11","dir":"Changelog","previous_headings":"","what":"Version 0.4-11","title":"Version 0.4-11","text":"#49 permit use \"quantile\" style probs= argument; really use n=, probs set internally seq(0, 1, 1/n). vectors, use \"fixed\" style preferable.","code":""},{"path":"https://r-spatial.github.io/classInt/news/index.html","id":"version-04-10","dir":"Changelog","previous_headings":"","what":"Version 0.4-10","title":"Version 0.4-10","text":"CRAN release: 2023-09-05 #46 limiting use nsamp=. #44 correcting logic largeN= handling.","code":""},{"path":"https://r-spatial.github.io/classInt/news/index.html","id":"version-04-9","dir":"Changelog","previous_headings":"","what":"Version 0.4-9","title":"Version 0.4-9","text":"CRAN release: 2023-02-28 #41 issues. maximum minimum breaks set   avoid errors induced earlier version breaks cease strictly ascending.  argument value  may used revert previous behaviour.","code":""},{"path":"https://r-spatial.github.io/classInt/news/index.html","id":"version-04-8","dir":"Changelog","previous_headings":"","what":"Version 0.4-8","title":"Version 0.4-8","text":"CRAN release: 2022-09-29 #18 #38: classIntervals() new style \"box\", box map augmented quartile map, additional lower upper category. lower outliers, starting point breaks minimum value, second break lower fence. lower outliers, starting point breaks lower fence, second break minimum value (observations fall interval lower fence minimum value) (@angela-li, @dieghernan).","code":""},{"path":"https://r-spatial.github.io/classInt/news/index.html","id":"version-04-7","dir":"Changelog","previous_headings":"","what":"Version 0.4-7","title":"Version 0.4-7","text":"CRAN release: 2022-06-10 new helper function classify_intervals() introduced return vector class intervals length input (@JosiahParry) classIntervals() new style \"maximum\" returns maximum breaks classification based pysal library mapclassify (@JosiahParry) findCols() now takes new argument factor , TRUE returns class membership factor intervals labels (@JosiahParry)","code":""},{"path":"https://r-spatial.github.io/classInt/news/index.html","id":"version-04-3","dir":"Changelog","previous_headings":"","what":"Version 0.4-3","title":"Version 0.4-3","text":"CRAN release: 2020-04-07 clarify dataPrecision= argument help page Add \"headtails\" vignette (@dieghernan) Add \"headtails\" style (@dieghernan)","code":""}]
